import { UploaderInput, UploadResult, IModule } from '../types';
import { google } from 'googleapis';
import { Readable } from 'stream';
import { Buffer } from 'buffer';

/**
 * Phase 6: Uploader & Scheduler (Real Implementation)
 * 
 * Goal: Upload video to YouTube using OAuth2 credentials.
 */
export class UploaderScheduler implements IModule<UploaderInput, UploadResult> {
  name = "Uploader & Scheduler";
  description = "Uploads video to YouTube via API and configures release schedule.";

  async execute(input: UploaderInput): Promise<UploadResult> {
    // 1. Validation
    if (!input.video_asset || input.video_asset.status !== 'generated') {
      throw new Error("Invalid video asset.");
    }
    if (!input.metadata || !input.metadata.title_template) {
      throw new Error("Missing video metadata.");
    }

    // 2. Check for Credentials (Real Mode) vs Simulation
    // We check if credentials exist in input AND if the server has the Client ID configured.
    if (input.authCredentials && process.env.GOOGLE_CLIENT_ID) {
      return this.uploadReal(input);
    } else {
      if (!input.authCredentials) {
        console.warn("[Uploader] Missing OAuth Credentials. Falling back to Simulation.");
      } else {
        console.warn("[Uploader] Server missing GOOGLE_CLIENT_ID. Falling back to Simulation.");
      }
      return this.uploadSimulated(input);
    }
  }

  private async uploadReal(input: UploaderInput): Promise<UploadResult> {
    console.log(`[Uploader] Starting REAL upload to YouTube...`);

    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      process.env.GOOGLE_REDIRECT_URI
    );

    oauth2Client.setCredentials(input.authCredentials!);

    const service = google.youtube({ version: 'v3', auth: oauth2Client });

    // Convert Base64 Data URI to Stream
    const videoStream = this.base64ToStream(input.video_asset.video_url);

    try {
      const response = await service.videos.insert({
        part: ['snippet', 'status'],
        requestBody: {
          snippet: {
            title: input.metadata.title_template,
            description: input.metadata.description_template + "\n\nGenerated by Shorts Automation System #Shorts",
            tags: ["Shorts", "AI", "Automated"],
            categoryId: '28' // Science & Technology
          },
          status: {
            privacyStatus: input.schedule.privacy_status,
            publishAt: input.schedule.publish_at // Only works if privacyStatus is private/scheduled logic
          }
        },
        media: {
          body: videoStream,
          mimeType: 'video/mp4'
        }
      });

      console.log(`[Uploader] Upload Success! ID: ${response.data.id}`);

      return {
        platform: 'youtube',
        video_id: response.data.id || 'unknown',
        platform_url: `https://youtube.com/shorts/${response.data.id}`,
        status: input.schedule.publish_at ? 'scheduled' : 'uploaded',
        scheduled_for: input.schedule.publish_at,
        uploaded_at: new Date().toISOString()
      };

    } catch (error: any) {
      console.error("[Uploader] API Error:", error);
      throw new Error(`YouTube API Upload Failed: ${error.message}`);
    }
  }

  private async uploadSimulated(input: UploaderInput): Promise<UploadResult> {
    console.log(`[Uploader] Starting SIMULATED upload...`);
    await new Promise(resolve => setTimeout(resolve, 1500));
    const mockId = "dQw4w9WgXcQ"; 
    return {
      platform: 'youtube',
      video_id: mockId,
      platform_url: `https://youtube.com/shorts/${mockId}`,
      status: input.schedule.publish_at ? 'scheduled' : 'uploaded',
      scheduled_for: input.schedule.publish_at,
      uploaded_at: new Date().toISOString()
    };
  }

  private base64ToStream(dataUri: string): Readable {
    // Expected format: "data:video/mp4;base64,....."
    // Handle potential missing prefix if just base64 is passed (robustness)
    const base64Data = dataUri.includes('base64,') ? dataUri.split(';base64,').pop() : dataUri;
    
    if (!base64Data) throw new Error("Invalid Base64 URI");

    const buffer = Buffer.from(base64Data, 'base64');
    const stream = new Readable();
    stream.push(buffer);
    stream.push(null);
    return stream;
  }
}